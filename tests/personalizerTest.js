const puppeteer = require('puppeteer');
const { expect } = require('chai');
const fs = require('fs');
const path = require('path');
const { writeExcelReport } = require('../utils/reportWriter');


const VIEWPORT = { width: 1920, height: 1080 };
const allResults = [];
const testFailures = new Map(); // personalizerId -> retryCount
const MAX_RETRIES = 2;
const XLSX = require('xlsx');


function readExcelAsJson(filePath, sheetName) {
  const workbook = XLSX.readFile(filePath);
  const sheet = workbook.Sheets[sheetName];
  if (!sheet) {
    throw new Error(`Sheet '${sheetName}' not found in Excel file.`);
  }
  const data = XLSX.utils.sheet_to_json(sheet, { defval: '' });
  return data.map(row => ({
    url: typeof row.url === 'object' ? row.url.hyperlink || row.url.text : row.url,
    personalizerId: String(row.personalizerId),
    elementSelector: row.elementSelector,
    recommendation: row.recommendation === true || row.recommendation === 'TRUE',
    weight: typeof row.weight === 'string' ? row.weight.split(',').map(Number) : row.weight
  }));
}

// Read input from the Excel file generated by jsonToExcel.js
const excelFilePath = path.resolve(__dirname, '../filesToCheckPersonalizer.xlsx');

let personalizerItems = [];
const sheetName = 'PersonalizerItems'; // Change this to your desired sheet name
try {
  personalizerItems = readExcelAsJson(excelFilePath, sheetName);
  console.log('Loaded personalizer items:', personalizerItems);
} catch (err) {
  console.error('Excel read failed:', err.message);
}


if (!fs.existsSync('screenshots')) {
  fs.mkdirSync('screenshots');
}

function createTestResult(item) {
  return {
    personalizerId: item.personalizerId,
    type: '',
    url: item.url,
    elementSelector: item.elementSelector,
    domOrder: [],
    rankOrder: [],
    rankApiCall: false,
    rewardApiCall: false,
    rankFirstElement: '',
    domFirstElemet: '',
    domOrderCheckWithRankOrder: false,
    rankEventId: '',
    rewardEventId: '',
    rewardWeightList: item.weight,
    rewardWeight: '',
    error: null,
    screenshot: '',
  };
}

function getLocaleFromUrl(url) {
  const path = new URL(url).pathname;
  const parts = path.split('/').filter(Boolean);
  return parts.length > 0 ? parts[0] : null;
}

async function closeModals(page) {
  try {
    await page.evaluate(() => {
      document.querySelector('.modal-backdrop')?.remove();
      document.querySelector('.modal')?.remove();
      document.querySelector('#modalsRenderedAfterPageLoad')?.remove();
    });
  } catch (err) {
    console.warn('⚠️ Popup close failed:', err.message);
  }
}

async  function getTimestampedFilename(baseName, extension = 'png') {
  const now = new Date();

  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0'); // 01-12
  const day = String(now.getDate()).padStart(2, '0');        // 01-31
  const hours = String(now.getHours()).padStart(2, '0');     // 00-23
  const minutes = String(now.getMinutes()).padStart(2, '0'); // 00-59
  const seconds = String(now.getSeconds()).padStart(2, '0'); // 00-59

  const timestamp = `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
  return `${baseName}_${timestamp}.${extension}`;
}

function defineTest(item, retryAttempt = 0) {
  const {
    url,
    personalizerId,
    elementSelector,
    recommendation
  } = item;

  const locale = getLocaleFromUrl(url);
  const label = retryAttempt === 0 ? '🧪' : `♻️ Retry ${retryAttempt}`;
  const testTitle = recommendation
    ? `🎯 Recommendation Flow - personalizerId : ${personalizerId} & locale : ${locale}`
    : `🔀 Card Shuffle Flow - personalizerId : ${personalizerId} & locale : ${locale}`;

  describe(`${label} ${testTitle} - ${url}`, function () {
    this.timeout(120000);

    let browser, page;
    let rankResponse, rewardRequest;
    const result = createTestResult(item);

    before(async () => {
      browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox', `--window-size=${VIEWPORT.width},${VIEWPORT.height}`],
        defaultViewport: null,
      });
      result.type = retryAttempt === 0 ? 'Initial Run' : `Retry ${retryAttempt}`;
      page = await browser.newPage();
      await page.setRequestInterception(true);

      page.on('request', req => req.continue());

      page.on('response', async (response) => {
        const resUrl = response.url();
        if (resUrl.includes('/personalizerwrapperapi/v01/rank') && resUrl.includes(personalizerId)) {
          try {
            rankResponse = await response.json();
            result.rankApiCall = true;
            result.rankEventId = rankResponse.eventId;
          } catch (err) {
            console.error('❌ Failed to parse /rank:', err.message);
          }
        }

        if (resUrl.includes('/reward') && resUrl.includes(personalizerId)) {
          try {
            rewardRequest = {
              url: resUrl,
              status: response.status(),
              method: response.request().method(),
              payload: JSON.parse(response.request().postData()),
            };
            result.rewardApiCall = rewardRequest.status === 200;
            result.rewardEventId = rewardRequest.payload.eventId;
            result.rewardWeight = rewardRequest.payload.weight;
          } catch (err) {
            console.error('❌ Failed to parse /reward:', err.message);
          }
        }
      });

  // Set a common user-agent to help avoid bot detection
      await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36');
      // Retry navigation up to 3 times for transient network errors
      let navAttempts = 0;
      let navSuccess = false;
      while (navAttempts < 3 && !navSuccess) {
        try {
          await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 90000 });
          navSuccess = true;
        } catch (err) {
          navAttempts++;
          console.error(`Navigation attempt ${navAttempts} failed:`, err.message);
          if (navAttempts >= 3) throw err;
          await new Promise(res => setTimeout(res, 5000)); // Wait before retry
        }
      }
      await closeModals(page);
      await new Promise(res => setTimeout(res, 10000));
    });

    it(`${personalizerId} - validate rank vs DOM`, async function () {
      try {
  // Wait for network to be idle and add extra delay before searching for the selector
  await new Promise(res => setTimeout(res, 5000)); // Wait 5 seconds for dynamic content
  await page.waitForSelector(elementSelector, { timeout: 120000 }); // Increase timeout to 120 seconds

        const domOrder = await page.$$eval(`${elementSelector}`, els =>
          els.map(el => el.getAttribute('data-offerid') || el.getAttribute('data-offerkey'))
        );

        expect(domOrder.length).to.be.greaterThan(0);
        expect(rankResponse).to.not.be.null;

        if (!rankResponse || !Array.isArray(rankResponse.ranking)) {
          console.error('rankResponse validation failed. Full object:', JSON.stringify(rankResponse));
          // Track failure for retry
          const currentRetry = testFailures.get(personalizerId) || 0;
          testFailures.set(personalizerId, currentRetry + 1);
          throw new Error('rankResponse.ranking is undefined or not an array');
        }

        const rankOrderLength = Math.min(rankResponse.ranking.length, 4);
        const rankOrder = rankResponse.ranking.slice(0, rankOrderLength).map(r => r.id);

        const rewardActionId = rankResponse.rewardActionId;

        result.domOrder = domOrder;
        result.rankOrder = rankOrder;
        result.rankFirstElement = rankOrder[0];
        result.domFirstElemet = domOrder[0];
        result.domOrderCheckWithRankOrder = domOrder[0] === rewardActionId;

        const cardLinks = await page.$$(elementSelector + ' a');
        expect(cardLinks.length).to.be.greaterThan(0);

        await Promise.all([
          cardLinks[0].click(),
          page.waitForNavigation({ waitUntil: 'domcontentloaded' })
        ]);

        await new Promise(res => setTimeout(res, 10000));

        expect(domOrder[0]).to.equal(rewardActionId);
        expect(domOrder.slice(0, rankOrder.length)).to.deep.equal(rankOrder);
      } catch (error) {
        result.error = error.message;

        // Track failure for selector timeout or other errors
        if (error.name === 'TimeoutError' && error.message.includes('Waiting for selector')) {
          console.warn(`Selector not found for personalizerId ${personalizerId}: ${elementSelector}`);
          const currentRetry = testFailures.get(personalizerId) || 0;
          testFailures.set(personalizerId, currentRetry + 1);
        } else {
          // Track other failures as well
          const currentRetry = testFailures.get(personalizerId) || 0;
          testFailures.set(personalizerId, currentRetry + 1);
        }

        // Capture screenshot
        const fileName = await getTimestampedFilename(`${personalizerId}_retry${retryAttempt}`, 'png');
        const screenshotPath = path.join('screenshots', fileName);
        await page.screenshot({ path: screenshotPath });
        result.screenshot = screenshotPath;

        throw error; // rethrow so Mocha registers failure
      }
    });

    after(async () => {
      allResults.push(result);
      await browser.close();
    });
  });
}

//  Register all initial tests
personalizerItems.forEach(item => defineTest(item));

//  Register retries based on failures (up to max allowed)
after(async function () {
  for (let retry = 1; retry <= MAX_RETRIES; retry++) {
    const itemsToRetry = personalizerItems.filter(item => {
      const retriesSoFar = testFailures.get(item.personalizerId) || 0;
      return retriesSoFar >= retry;
    });

    if (itemsToRetry.length === 0) break;

    console.log(`\n🔁 Scheduling Retry ${retry} for ${itemsToRetry.length} items...\n`);
    itemsToRetry.forEach(item => defineTest(item, retry));
  }
});

// Final report after everything (including retries)
after(async function () {
  if (allResults.length > 0) {
    try {
      await writeExcelReport(allResults, 'personalizer_report');
      console.log(' Excel report successfully written!');
    } catch (err) {
      console.error('Failed to write Excel report:', err.message);
    }
  } else {
    console.warn('No results to write to Excel.');
  }
});
