const puppeteer = require('puppeteer');
const assert = require('assert');
const { writeExcelReport } = require('../utils/reportWriter');
const path = require('path');
const XLSX = require('xlsx');

const browserInfo =  'chrome';

const edgePathObj = {
    chrome:'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
    edge:'C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe'
}

const edgePath = edgePathObj[browserInfo];

const width = 1920;

const height = 1080;

function readExcelAsJson(filePath, sheetName) {
  const workbook = XLSX.readFile(filePath);
  const sheet = workbook.Sheets[sheetName];
  if (!sheet) {
    throw new Error(`Sheet '${sheetName}' not found in Excel file.`);
  }
  const data = XLSX.utils.sheet_to_json(sheet, { defval: '' });
  return data.map(row => ({
    url: typeof row.url === 'object' ? row.url.hyperlink || row.url.text : row.url,
    experimentId: String(row.exp_id),
    errorList: typeof row.type === 'string' ? row.type.split(',') : row.type
  }));
}

// Read input from the Excel file generated by jsonToExcel.js
const excelFilePath = path.resolve(__dirname, '../filesToCheckPersonalizer.xlsx');

let pages = [];
const sheetName = 'consoleError'; // Change this to your desired sheet name
try {
  pages = readExcelAsJson(excelFilePath, sheetName);
  console.log('Loaded personalizer items:', pages);
} catch (err) {
  console.error('Excel read failed:', err.message);
}

function defineTest() {

describe('Console log check using Puppeteer', function () {

  this.timeout(30000);

  var browser;

  const consoleMessages = [];

  before(async () => {
        browser = await puppeteer.launch({
            headless: true,
            args: [`--window-size=${width},${height}`],
            defaultViewport: null,
            executablePath:edgePath
        });
  });


  pages.forEach((item) => {
    const { url, experimentId, errorList } = item;

    if (!url || !experimentId || !errorList) {
      console.warn(`Skipping item with missing data: ${JSON.stringify(item)}`);
      return;
    }
    if (!Array.isArray(errorList)) {
      console.warn(`Invalid errorList for item ${experimentId}: ${errorList}`);
      return;
    }
    it(`should capture console messages for ${url}`, async () => {
      const page = await browser.newPage();

      page.on('console', msg => {
          if(errorList.includes('log') == true ||  msg.text().includes(experimentId)){
            consoleMessages.push({ type: msg.type(), message: msg.text(),URL:url});
          } 
      });

      page.on('pageerror', error => {  
         if(errorList.includes('pageerror') == true || error.message.includes(experimentId)){
            consoleMessages.push({ type: 'PAGE ERROR', message: error.message,URL:url});
          }   
      });

      page.on('requestfailed', req => {
            const errorText = req.failure().errorText; 
             if(errorList.includes('requestfailed') == true || errorText.includes(experimentId)){ 
                consoleMessages.push({ type: 'REQUEST FAILED', message: errorText,URL:url});
             }   
      });  

      await page.goto(url, { waitUntil: 'load' });

      await new Promise(resolve => setTimeout(resolve, 10000));

      const errors = consoleMessages.filter(msg => msg.message.includes(experimentId));
      
      assert.strictEqual(errors.length, 0, `Console errors found on ${url}`);

      await page.close();
    });
  });


  after(async () => {
    let nameOfFile = 'consoleLogs_';
    writeExcelReport(consoleMessages,nameOfFile);
    await browser.close();
  });
});
}

defineTest();
